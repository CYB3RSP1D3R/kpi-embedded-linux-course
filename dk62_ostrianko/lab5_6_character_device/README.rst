Звіт з виконання лабороторної роботи №4
=============================================

**У даній лабораторній роботі було виконано наступні задачі:**

* Виконати регістрацію девайсу в папці "/dev"
* Написати драйвер ядра з функціями read/write
* Заносити відкривані файли до дерева
* Реалізувати ioctl для можливості змінювати розмір буфера та виводу магічної фрази

ТЕОРЕТИЧНІ ВІДОМОСТІ
-------

Спосіб бачення пристроїв в `Linux` розділяється на *три фундаментальні типи*. Кожен модуль зазвичай реалізований як один з цих типів 
і таким чином класифікується як **символьний модуль**, **блочний модуль**, або **мережевий модуль**. Такий поділ модулів на різні типи 
або класи не є жорстким; програміст може при бажанні створювати великі модулі, що містять різні драйвера в одній частині коду.

**Символьний пристрій** - це такий пристроїв, до якого можна звертатися як до потоку байтів (так само як до файлу). 
Драйвер символьного пристрою відповідає за реалізацію цієї поведінки. Даний драйвер, зазвичай,  підтримує системні виклики, 
такі як: *open*, *close*, *read* і *write*. Прикладами символьних пристроїв є: текстовий екран ``(/dev/console)`` і 
послідовні порти ``(/dev/ttyS0 і подібні)``. Для звернення до символьних пристроїв використовують вузли *(node)* файлової системи, 
такі як ``/dev/tty1`` і ``/dev/lp0``. Єдине **важлива відмінність** між символьними пристроями і звичайними файлами - це можливість 
рухатися вперед і назад у *звичайному файлі*, в той час як більшість *символьних пристроїв* - це тільки канали даних, в яких існує 
спосіб звертатися лише послідовно.

**file_operations()**


Структура **file_operations** оголошена у файлах ``linux/fs.h``.
Структура являє собою масив вказівників на різні функції. Операції, зазвичай, відповідають за реалізацію системних викликів. Вказавши 
функції у відповідність данним вказівникам, ми можемо задати що саме буде виконувати та чи інша функція драйверу, при використанні системних 
викликів по відношенню до цього драйвера.

Драйвер в більшості випадків, реалізує не всі функції в заданій структурі. Для кожної конкретної задачі, потрібний свій список функцій.
Нижче наведенно, які саме операції будуть використані в даній лабораторній роботі:

.. code-block:: c

	static struct file_operations hive_fops = {
		.open =    &cdev_open,
		.release = &cdev_release,
		.read =    &cdev_read,
		.write =   &cdev_write,
		.llseek =   &cdev_lseek,
		// required to prevent module unloading while fops are in use
		.owner =   THIS_MODULE,
	};

Функції, які не використано заповнюються "пустими" вказівниками - **NULL**.

**ioctl()**


Системний виклик **ioctl()** - це універсальний засіб управління апаратними пристроями.
Завдяки запитам **ioctl()** можна керувати багатьма оперативними характеристиками спеціальних символьних файлів.
Для використання такої функцій слід підключити ``<linux/ioctl.h>``.

.. code-block:: c
	int ioctl(int fd, int cmd, ...);

Завдяки невизначеному списку параметрів, даний прототип сильно виділяється із списку системних викликів *Unix*, які, зазвичай, 
представлені фіксованим числом формальних параметрів. Однак, в реальній системі, системний виклик не може мати змінне число параметрів.
Системні виклики повинні мати чітко визачену кількість аргументів, так як призначені для користувача програми, можуть отримати доступ 
до них тільки через апаратну частину.

**Першим аргументом** функції є дескриптор файлу того пристрою, яким потрібно керувати. **Другий аргумент** - це код запиту, що 
позначає операцію, яка буде виконуватися. Різним пристроям відповідають різні запити. Залежно від запиту функції **ioctl()** можуть 
знадобитися додаткові аргументи. **Третій аргумент** - нетипізований вказівник на пам'ять. Це традиційно **char * argp**.

**Хід роботи:**
========

У даній роботі було реалізовано елементарні функції open/release/read/write. Розглянемо кожну з них тезово.

**Функція open**


Створює новий елемент, резервує місце під нього та під його буфер, додає у відповідність файл що було відкрито та додає даний елемент до дерева.

**Функція release**

Вилучає елемент з дерева.

**Функція read**

На вхід приймає вказівник на файл, вказівник на буфер для зчитування, лічильник, який вказує яку кількусть байт необхідно зчитати та поточний відступ.

З першого погляду функція працює досить просто: є буфер для зчитування, є буфер елементу з якого необхідно зчитати, та кількість байтів 
які необхідно зчитати. Єдине що необхідно враховувати, що буфер для зчитування та буфер елементу знаходяться в різних областях пам'яті, 
та для впевненості краще скоритсатися функцією ``copy_to_user()``, яка передбачена для таких ситуацій.

Проте для багаторазового зчитування необхідно відстежувати поточне положення курсору. Для цього у даної функції є знячення відступу ``loff_t *loff`` 
який у даному випадку виконує роль курсора. Все просто, необхідно стежити за тим щоб курсор не вийшов за межі буферу, та по мірі зчитування 
збільшувати його значення. Якщо ж курсор досягне кінця буферу, зчитування буде неможливим, адже читати більше нічого.

**Функція write**

Дана функція за принципом дії являється повною аналогією функції **read**, єдина різниця - буфери помінялися місцями, та використання функції 
``copy_from_user()`` замість ``copy_to_user()``.

Дерево
-----

Також у даній роботі було реалізовано один з різновидів бінарного дерева. Суть даного дерева нічим не відрізняється від звичайного бінарного 
дерева: якщо значення елемента більше, 
елемент відходить до правої вітки дерева, меньше - до лівої. Проте це не зовсім класичне бінарне дерево, адже корім вказівників на правого 
та лівого нащадка, у кожного елемента дерева також є вказівник на предка. Даний вказівник дозволяє повернутися з кінцевих елементів дерева 
вгору.

Розглянемо роботу з бінарним деревом.
-----

**Додавання елемента до бінарного дерева.**

Додавання елемента здійснюється досить просто, порівнюючи значення нового елемента зі значеннями дерева, поступово пересуваючись від кореня 
далі по дереву, вправо чи вліво залежно від того більше значення нового елемента за значення поточного елемента чи, меньше відповідно. Таке 
пересування по дереву продовжується до тих пір, допоки не буде досягнуто кінця вітки. У такому разі, відповідний вказівник буде направлено 
на новий єлемент. На цьому додавання нового елемента до дерева можна вважати завершеним.

**Пошук елемента в бінарному дереві.**

Пошук елемента в бінарному дереві також не надто складна задача. Полягає вона в наступному: по черзі порівнювати шукане значення зі значенням 
поточного елемента, у разі якщо значення співпаде - повернути елемент, у противному випадку рухаємося вправо чи вліво по аналогії з додаванням елементу.

**Знаходження мінімального елементу гілки.**

Для знаходження мілімального елементу гілки необхідно завжди пересуватися до лівого нащадка, аж допоки не достигнемо кінця гілки.

**Видалення елементу дерева.**

Видалення елементу являє собою найскладнішу з функцій для роботи з деревом. Адже для коректного видалення елементу з дерева необхідно 
передбачити чотири наступні варіанти:

* Елемент не має нащадків
* Елемент не має одного з нащадків
* Елемент має обох нащадків, проте в правого (або лівого, залежить від реалізації) не має лівого (правого) нащадка 
* Елемент має обох нащадків, у кожного з яких також є обидва нащадки

1. В першому випадку необхідно вказати предку що в нього більше нема нащадка, а самого нащадка можна видалити.

2. В другому випадку предку необхідно вказати нового нащадка, який являвся нащадком того що буде вилучено, та навпаки (для даної реалізації).

3. У третьому випадку місце видаляємого елемента займає правий (лівий) нащадок, та переймає його лівого (правого) нащадка собі.

4. Останній варіант є найскладнішим, адже у такому випадку треба знайти мінімальний (максимальний) елемент правої (лівої) підгілки, вилучити 
його за другим методом, та поставити на місце видаляємого, успадкувавши всі зв'язки.




